---
phase: 12-ble-connection-facade
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/KableBleConnectionManager.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/data/ble/KableBleConnectionManagerTest.kt
autonomous: true
must_haves:
  truths:
    - "KableBleConnectionManager contains all scan/connect/disconnect lifecycle code"
    - "Auto-reconnect flag logic (wasEverConnected + isExplicitDisconnect) is preserved as a unit inside the state observer"
    - "Connection retry loop (3 attempts) is preserved with same timeout/delay constants"
    - "sendWorkoutCommand routes through BleOperationQueue with retry logic"
    - "Notification subscriptions (REPS, VERSION, MODE) start after device ready"
    - "Unit tests verify connection state transitions and auto-reconnect flag logic"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/KableBleConnectionManager.kt"
      provides: "Connection lifecycle manager with Peripheral ownership"
      contains: "class KableBleConnectionManager"
    - path: "shared/src/commonTest/kotlin/com/devil/phoenixproject/data/ble/KableBleConnectionManagerTest.kt"
      provides: "Unit tests for connection lifecycle"
      contains: "class KableBleConnectionManagerTest"
  key_links:
    - from: "KableBleConnectionManager"
      to: "BleOperationQueue"
      via: "bleQueue constructor parameter"
      pattern: "bleQueue\\.write"
    - from: "KableBleConnectionManager"
      to: "MetricPollingEngine"
      via: "pollingEngine constructor parameter"
      pattern: "pollingEngine\\.startAll"
    - from: "KableBleConnectionManager"
      to: "DiscoMode"
      via: "discoMode constructor parameter"
      pattern: "discoMode\\.stop"
    - from: "KableBleConnectionManager"
      to: "KableBleRepository (facade)"
      via: "callback lambdas for state/event emission"
      pattern: "onConnectionStateChanged\\|onScannedDevicesChanged\\|onReconnectionRequested"
---

<objective>
Create KableBleConnectionManager with ALL connection lifecycle code extracted from KableBleRepository.

Purpose: This is the final extraction of v0.4.2 — moving the core BLE connection lifecycle (scan, connect with retry, disconnect, auto-reconnect, notification subscriptions, device readiness, command sending) into a focused manager class. The ConnectionManager owns the Peripheral reference exclusively.

Output: KableBleConnectionManager.kt (~850 lines) with complete connection lifecycle, plus unit tests for state transitions and auto-reconnect logic.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-ble-connection-facade/12-RESEARCH.md
@.planning/phases/11-metric-polling-engine/11-02-SUMMARY.md

@shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/KableBleRepository.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/BleRepository.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/MetricPollingEngine.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/DiscoMode.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/BleOperationQueue.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/HandleStateDetector.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/util/BleConstants.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KableBleConnectionManager with all connection lifecycle code</name>
  <files>shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/KableBleConnectionManager.kt</files>
  <action>
Create `KableBleConnectionManager.kt` in the `com.devil.phoenixproject.data.ble` package by extracting connection lifecycle code from KableBleRepository (lines 172-929, 943-1224, 1144-1192).

**Constructor signature** — follows the established callback-based pattern from DiscoMode (Phase 8), MonitorDataProcessor (Phase 10), and MetricPollingEngine (Phase 11):

```kotlin
class KableBleConnectionManager(
    private val scope: CoroutineScope,
    private val logRepo: ConnectionLogRepository,
    private val bleQueue: BleOperationQueue,
    private val pollingEngine: MetricPollingEngine,
    private val discoMode: DiscoMode,
    private val handleDetector: HandleStateDetector,
    // Callbacks for event routing to facade flows
    private val onConnectionStateChanged: (ConnectionState) -> Unit,
    private val onScannedDevicesChanged: (List<ScannedDevice>) -> Unit,
    private val onReconnectionRequested: suspend (ReconnectionRequest) -> Unit,
    private val onCommandResponse: (UByte) -> Unit,
    // Callbacks for notification data routing
    private val onRepEventFromCharacteristic: (ByteArray) -> Unit,
    private val onRepEventFromRx: (ByteArray) -> Unit,
    private val onMetricFromRx: (ByteArray) -> Unit,
)
```

**State variables to move** (9 mutable fields + 1 map):
- `peripheral: Peripheral?` (line 173) — THE central ownership variable
- `discoveredAdvertisements: MutableMap<String, Advertisement>` (line 174)
- `scanJob: Job?` (line 175)
- `connectedDeviceName: String` (line 180)
- `connectedDeviceAddress: String` (line 181)
- `isExplicitDisconnect: Boolean` (line 216)
- `wasEverConnected: Boolean` (line 221)
- `detectedFirmwareVersion: String?` (line 208)
- `@Volatile negotiatedMtu: Int?` (line 211)

**Public read-only accessor** for Peripheral reference:
```kotlin
val currentPeripheral: Peripheral? get() = peripheral
```

**Characteristic references** — copy from KableBleRepository (lines 70-79):
```kotlin
private val txCharacteristic = BleConstants.txCharacteristic
private val rxCharacteristic = BleConstants.rxCharacteristic
private val monitorCharacteristic = BleConstants.monitorCharacteristic
private val repsCharacteristic = BleConstants.repsCharacteristic
private val diagnosticCharacteristic = BleConstants.diagnosticCharacteristic
private val heuristicCharacteristic = BleConstants.heuristicCharacteristic
private val versionCharacteristic = BleConstants.versionCharacteristic
private val modeCharacteristic = BleConstants.modeCharacteristic
private val firmwareRevisionCharacteristic = BleConstants.firmwareRevisionCharacteristic
```

**Methods to move** (copy exactly, then update references):

1. `startScanning(): Result<Unit>` (lines 223-373) — Replace `_connectionState.value =` with `onConnectionStateChanged(...)`, replace `_scannedDevices.value =` with `onScannedDevicesChanged(...)`. All scanning state logic stays intact.

2. `stopScanning()` (lines 375-387) — Uses `onConnectionStateChanged` callback. Note: needs a way to check current connection state for the `if (_connectionState.value == ConnectionState.Scanning)` guard. Add a `currentConnectionState: () -> ConnectionState` constructor parameter, OR use a local tracking variable. Recommendation: add a `private var lastReportedState: ConnectionState = ConnectionState.Disconnected` that mirrors what was sent via callback, so the stopScanning guard works correctly.

3. `scanAndConnect(timeoutMs: Long): Result<Unit>` (lines 393-440) — Uses `onConnectionStateChanged`, `onScannedDevicesChanged`. Calls internal `connect()`.

4. `connect(device: ScannedDevice): Result<Unit>` (lines 442-627) — **CRITICAL: Move the entire state observer (peripheral?.state?.onEach) as a unit.** The auto-reconnect flag logic (wasEverConnected, isExplicitDisconnect) MUST stay with the state observer. Replace `_connectionState.value =` with `onConnectionStateChanged(...)`. Replace `_reconnectionRequested.emit(...)` with `scope.launch { onReconnectionRequested(...) }`. The `onDeviceReady()` call stays as internal call.

5. `onDeviceReady()` (lines 633-749) — Calls requestHighPriority, requestMtuIfSupported, service discovery logging, then startObservingNotifications(). All stays internal.

6. `startObservingNotifications()` (lines 751-841) — Notification subscriptions for REPS, VERSION, MODE characteristics. REPS data routed via `onRepEventFromCharacteristic(data)` callback. VERSION and MODE are log-only (stay internal). Calls `discoMode.stop()` then `pollingEngine.startAll(p)` at the end.

7. `tryReadFirmwareVersion(p: Peripheral)` (lines 847-867) — Internal, uses bleQueue.read.

8. `tryReadVitruvianVersion(p: Peripheral)` (lines 873-885) — Internal, uses bleQueue.read.

9. `disconnect()` (lines 903-917) — Sets `isExplicitDisconnect = true`, calls `pollingEngine.stopAll()`, `peripheral?.disconnect()`, nulls peripheral, calls `onConnectionStateChanged(Disconnected)`.

10. `cancelConnection()` (lines 919-929) — Sets `isExplicitDisconnect = true`, disconnects, nulls peripheral, calls `onConnectionStateChanged(Disconnected)`.

11. `cleanupExistingConnection()` (lines 1151-1176) — Internal pre-connect cleanup. Sets `isExplicitDisconnect = true`, calls `pollingEngine.stopAll()`, disconnects existing peripheral.

12. `sendWorkoutCommand(command: ByteArray): Result<Unit>` (lines 943-1012) — Uses `peripheral` directly, routes through `bleQueue.write()`. The post-CONFIG diagnostic one-shot read stays here (calls internal `parseDiagnosticData`). Uses `connectedDeviceName`/`connectedDeviceAddress` for logging.

13. `processIncomingData(data: ByteArray)` (lines 1178-1192) — Routes opcode to callbacks: `onCommandResponse(opcode)`, `onMetricFromRx(data)` for opcode 0x01, `onRepEventFromRx(data)` for opcode 0x02.

14. `parseDiagnosticData(bytes: ByteArray)` (lines 891-901) — Internal, self-contained diagnostic parsing and logging. Per [11-02] decision: stays simplified, no fault-change tracking.

15. `awaitResponse(expectedOpcode: UByte, timeoutMs: Long): Boolean` (lines 1202-1224) — `@Suppress("unused")`, reserved for future protocol handshakes. Needs a `commandResponses` flow reference. Since `_commandResponses` is in the facade, either: (a) keep it in the facade (simpler), or (b) create a local MutableSharedFlow in the manager. Recommendation: the manager already calls `onCommandResponse(opcode)`. Create a local `_commandResponses` SharedFlow in the manager for awaitResponse to consume. The callback to the facade is in addition to the local flow. OR simpler: just move the entire `_commandResponses` and `awaitResponse()` pair into the manager.

**IMPORTANT implementation notes:**
- Do NOT move any Flow/StateFlow declarations (`_connectionState`, `_scannedDevices`, etc.) — those stay in the facade (interface contract).
- The ConnectionManager communicates exclusively via callbacks.
- Logger tag: `"KableBleConnectionManager"`.
- The file needs all the same imports as the moved code uses (Kable, coroutines, BleConstants, etc.).
- For the `currentTimeMillis()` utility, either import it or add a private copy: `private fun currentTimeMillis() = Clock.System.now().toEpochMilliseconds()`.
- The `_commandResponses` flow + `awaitResponse()` can be self-contained in the manager. The manager emits to both its internal flow (for awaitResponse) and the callback (for external consumers). Or simplify: move both into manager, expose `commandResponses` as a public Flow. The facade can expose it if needed.

**At this point, KableBleRepository still has the old code — compilation MAY break temporarily.** This is expected and will be fixed in Plan 12-02.
  </action>
  <verify>
File exists at `shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/KableBleConnectionManager.kt`.
Verify class compiles in isolation: `./gradlew :shared:compileKotlinMetadata 2>&1 | head -30` (may show warnings about unused code in facade, but the new file should compile).
Verify constructor has all required callback parameters.
Verify `peripheral` is private with `currentPeripheral` public getter.
Verify auto-reconnect flags (`wasEverConnected`, `isExplicitDisconnect`) are private and only accessed within the state observer and disconnect/cancelConnection methods.
  </verify>
  <done>
KableBleConnectionManager.kt exists with all 15 methods moved from KableBleRepository, all 9 state variables moved, callback-based event routing, and Peripheral ownership. The class compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for KableBleConnectionManager lifecycle</name>
  <files>shared/src/commonTest/kotlin/com/devil/phoenixproject/data/ble/KableBleConnectionManagerTest.kt</files>
  <action>
Create `KableBleConnectionManagerTest.kt` following the established MetricPollingEngineTest pattern — test lifecycle and callback routing without requiring a real Peripheral.

**Test the following scenarios:**

1. **Initial state:** `currentPeripheral` is null after construction.

2. **Callback routing - processIncomingData:**
   - Send data with opcode 0x01 (metrics) — verify `onMetricFromRx` callback fires with the data.
   - Send data with opcode 0x02 (rep) — verify `onRepEventFromRx` callback fires with the data.
   - Send data with opcode 0x01 but size < 16 — verify `onMetricFromRx` does NOT fire.
   - Send data with opcode 0x02 but size < 5 — verify `onRepEventFromRx` does NOT fire.
   - Any data — verify `onCommandResponse` callback fires with the opcode byte.

3. **Disconnect sets flags correctly:**
   - After calling `disconnect()`, verify `currentPeripheral` is null.
   - Verify `onConnectionStateChanged` callback fires with `ConnectionState.Disconnected`.

4. **parseDiagnosticData does not throw on valid/invalid data:**
   - Pass a valid diagnostic packet (use a known byte array from ProtocolParser tests if available).
   - Pass an empty byte array — verify no crash.

Note: Connection, scanning, and auto-reconnect tests require Kable Peripheral mocking which is not feasible with the current test infrastructure (per Phase 11 precedent). These will be verified via manual BLE testing (FACADE-03). The tests here focus on callback routing and state management that CAN be tested in isolation.

Since `processIncomingData` is private, the test approach depends on how it's exposed. If it remains private, test it indirectly through a package-private or `internal` accessor. Alternatively, make `processIncomingData` `internal` for testability (consistent with how MetricPollingEngine exposes `startFakeJobs` for testing).

Create the test class with `runTest` from `kotlinx.coroutines.test`.
  </action>
  <verify>
Run tests: `./gradlew :androidApp:testDebugUnitTest --tests "*.KableBleConnectionManagerTest" 2>&1 | tail -20`
All tests pass.
  </verify>
  <done>
Unit tests exist and pass for KableBleConnectionManager callback routing (processIncomingData opcode dispatch), disconnect state cleanup, and diagnostic parsing safety.
  </done>
</task>

</tasks>

<verification>
1. `KableBleConnectionManager.kt` exists in `data/ble/` package
2. Class has constructor with scope, logRepo, bleQueue, pollingEngine, discoMode, handleDetector, and 7 callback lambdas
3. All 15 methods from KableBleRepository are present in the manager
4. All 9 state variables + discoveredAdvertisements map are in the manager
5. `peripheral` is private, `currentPeripheral` is public read-only
6. Auto-reconnect flag logic preserved in state observer (wasEverConnected + isExplicitDisconnect)
7. Connection retry loop uses BleConstants.Timing.CONNECTION_RETRY_COUNT (3)
8. Unit tests pass
9. No modifications to KableBleRepository yet (that's Plan 12-02)
</verification>

<success_criteria>
- KableBleConnectionManager.kt compiles with all connection lifecycle code
- Unit tests pass for callback routing and state management
- File is ~800-900 lines containing all extracted connection lifecycle code
- Peripheral ownership is exclusive to the manager
- Auto-reconnect flag coordination preserved intact
</success_criteria>

<output>
After completion, create `.planning/phases/12-ble-connection-facade/12-01-SUMMARY.md`
</output>
