---
phase: 06-protocol-parser
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/ProtocolParser.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/data/ble/ProtocolParserTest.kt
autonomous: true

must_haves:
  truths:
    - "Byte utilities parse Little-Endian and Big-Endian integers correctly"
    - "Sign extension is handled correctly for signed integers"
    - "Float parsing matches IEEE 754 format"
    - "All byte utilities work on ByteArray inputs without external dependencies"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/ProtocolParser.kt"
      provides: "Pure byte parsing functions"
      contains: "fun getUInt16LE"
    - path: "shared/src/commonTest/kotlin/com/devil/phoenixproject/data/ble/ProtocolParserTest.kt"
      provides: "Unit tests for byte utilities"
      contains: "class ProtocolParserTest"
  key_links:
    - from: "ProtocolParserTest.kt"
      to: "ProtocolParser.kt"
      via: "import and function calls"
      pattern: "import.*ProtocolParser|getUInt16LE|getInt16LE"
---

<objective>
Create ProtocolParser.kt with byte-level utility functions using TDD approach.

Purpose: Establish the foundation for stateless byte parsing with comprehensive test coverage. Byte utilities are the primitives used by all packet parsers.

Output: ProtocolParser.kt with 6 byte utility functions and ProtocolParserTest.kt with ~15 unit tests.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-protocol-parser/06-RESEARCH.md

# Reference existing patterns
@shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/KableBleRepository.kt (lines 2630-2683)
@shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/model/WorkoutMetricTest.kt (test structure reference)
</context>

<feature>
  <name>Byte Utility Functions</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/ProtocolParser.kt
    shared/src/commonTest/kotlin/com/devil/phoenixproject/data/ble/ProtocolParserTest.kt
  </files>
  <behavior>
    Six pure functions for extracting integers/floats from ByteArray:

    1. getUInt16LE(data, offset) - Unsigned 16-bit Little-Endian
       - Input: [0x01, 0x02] at offset 0 -> Output: 513
       - Input: [0xFF, 0xFF] -> Output: 65535 (not -1)

    2. getInt16LE(data, offset) - Signed 16-bit Little-Endian
       - Input: [0x00, 0x10] -> Output: 4096
       - Input: [0xFF, 0xFF] -> Output: -1 (sign extended)
       - Input: [0x00, 0x80] -> Output: -32768

    3. getUInt16BE(data, offset) - Unsigned 16-bit Big-Endian
       - Input: [0x01, 0x02] -> Output: 258
       - Input: [0xFF, 0xFF] -> Output: 65535

    4. getInt32LE(data, offset) - Signed 32-bit Little-Endian
       - Input: [0x01, 0x02, 0x03, 0x04] -> Output: 67305985
       - Input: [0xFF, 0xFF, 0xFF, 0xFF] -> Output: -1

    5. getFloatLE(data, offset) - 32-bit IEEE 754 Little-Endian
       - Input: [0x00, 0x00, 0x80, 0x3F] -> Output: 1.0f
       - Input: [0x00, 0x00, 0x96, 0x43] -> Output: 300.0f

    6. Byte.toVitruvianHex() - Two-character uppercase hex string
       - Input: 0xFF.toByte() -> Output: "FF"
       - Input: 0x0A.toByte() -> Output: "0A"

    CRITICAL: All functions MUST mask with `and 0xFF` to prevent sign extension bugs.
  </behavior>
  <implementation>
    Create pure top-level functions in ProtocolParser.kt (not an object, to emphasize statelessness).
    Copy exact implementation from KableBleRepository.kt lines 2634-2683, making them public.
    Package: com.devil.phoenixproject.data.ble
  </implementation>
</feature>

<verification>
```bash
# Run unit tests
./gradlew :shared:testDebugUnitTest --tests "com.devil.phoenixproject.data.ble.ProtocolParserTest"

# Verify test output shows all passing
```
</verification>

<success_criteria>
1. All 6 byte utility functions exist as public top-level functions
2. All unit tests pass (RED then GREEN for each function)
3. Sign extension correctly handled (0xFF.toByte() masks to 255, not -1)
4. Both Little-Endian and Big-Endian parsing verified
5. Float parsing matches IEEE 754 (1.0f = 0x3F800000)
</success_criteria>

<output>
After completion, create `.planning/phases/06-protocol-parser/06-01-SUMMARY.md`
</output>
