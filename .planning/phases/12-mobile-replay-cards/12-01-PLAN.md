---
phase: 12-mobile-replay-cards
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/replay/RepBoundaryDetector.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/replay/RepBoundaryDetectorTest.kt
autonomous: true

must_haves:
  truths:
    - "Rep boundaries are detected from position data using valley detection with smoothing"
    - "Rep isolation produces accurate concentric and eccentric phase segments"
    - "Edge cases (single rep, incomplete reps, noisy data) are handled gracefully"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/replay/RepBoundaryDetector.kt"
      provides: "Valley-based rep boundary detection with smoothing"
      exports: ["RepBoundaryDetector", "RepBoundary"]
    - path: "shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/replay/RepBoundaryDetectorTest.kt"
      provides: "Comprehensive test coverage for boundary detection"
      min_lines: 100
  key_links:
    - from: "RepBoundaryDetector"
      to: "MetricSample position data"
      via: "FloatArray of positions"
      pattern: "detectBoundaries.*positions"
---

<objective>
Implement valley-based rep boundary detection algorithm that segments position time-series into individual reps.

Purpose: Enable accurate isolation of each rep's concentric and eccentric phases from raw MetricSample data for replay visualization.

Output: RepBoundaryDetector class with detectBoundaries function that returns rep start/end indices.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference implementation for valley detection (already proven in Phase 11)
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/detection/SignatureExtractor.kt

# Domain model with position/load/velocity arrays
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/RepMetrics.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: RepBoundaryDetector with TDD (RED -> GREEN)</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/replay/RepBoundaryDetector.kt
    shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/replay/RepBoundaryDetectorTest.kt
  </files>
  <action>
Create rep boundary detection using the proven valley detection pattern from SignatureExtractor.

**Domain Models (in RepBoundaryDetector.kt):**
```kotlin
data class RepBoundary(
    val repNumber: Int,          // 1-indexed
    val startIndex: Int,         // Valley start index in position array
    val peakIndex: Int,          // Peak position index (concentric -> eccentric transition)
    val endIndex: Int,           // Valley end index (next rep start or array end)
    val concentricIndices: IntRange,  // startIndex until peakIndex
    val eccentricIndices: IntRange    // peakIndex until endIndex
)
```

**Algorithm (based on SignatureExtractor but for replay use):**
1. Apply 5-sample moving average smoothing to position data
2. Detect valleys using local minima detection (+/- 2 sample window)
3. Valleys must have minimum prominence (10mm below surrounding peaks)
4. Minimum 8 samples between valleys to prevent false positives
5. Find peak between each valley pair for concentric/eccentric split

**TDD Tests to Write FIRST:**
1. `detectBoundaries returns empty for insufficient data (less than 15 samples)`
2. `detectBoundaries finds single rep boundaries correctly`
3. `detectBoundaries finds multiple rep boundaries correctly`
4. `detectBoundaries handles edge valleys (start/end of data)`
5. `detectBoundaries identifies peak position for phase split`
6. `concentricIndices and eccentricIndices partition rep correctly`
7. `noisy data with smoothing still detects correct valleys`
8. `minimum valley separation prevents false positives`

**Test Data Helpers:**
Create helper functions to generate synthetic position data:
- `buildSingleRepPositions(valleyMm, peakMm, sampleCount)` - generates V-shaped position curve
- `buildMultiRepPositions(repCount, valleyMm, peakMm, samplesPerRep)` - repeating V patterns

Write tests FIRST (RED), run to verify they fail, then implement RepBoundaryDetector (GREEN).
  </action>
  <verify>
Run `./gradlew :shared:testDebugUnitTest --tests "*RepBoundaryDetectorTest*"` - all tests pass
  </verify>
  <done>
RepBoundaryDetector correctly segments position arrays into rep boundaries with concentric/eccentric phase indices. At least 8 passing tests covering normal cases and edge cases.
  </done>
</task>

</tasks>

<verification>
1. Run unit tests: `./gradlew :shared:testDebugUnitTest --tests "*RepBoundaryDetectorTest*"`
2. Verify RepBoundaryDetector.kt exists with detectBoundaries function
3. Verify RepBoundary data class has startIndex, peakIndex, endIndex, concentricIndices, eccentricIndices
4. Confirm test coverage includes: empty data, single rep, multiple reps, noisy data, edge valleys
</verification>

<success_criteria>
- RepBoundaryDetector.detectBoundaries(positions: FloatArray) returns List<RepBoundary>
- Each RepBoundary contains accurate phase indices verified by tests
- Smoothing algorithm matches Phase 11 pattern (5-sample moving average)
- All unit tests pass with green checkmarks
</success_criteria>

<output>
After completion, create `.planning/phases/12-mobile-replay-cards/12-01-SUMMARY.md`
</output>
