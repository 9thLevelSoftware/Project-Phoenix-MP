---
phase: 03-rep-quality-scoring
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/RepQualityScorer.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/RepQuality.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/RepQualityScorerTest.kt
autonomous: true

must_haves:
  truths:
    - "Each rep receives a composite quality score 0-100 from four weighted components"
    - "ROM consistency contributes up to 30 points based on deviation from set average"
    - "Velocity consistency contributes up to 25 points based on deviation from set average"
    - "Eccentric control contributes up to 25 points based on ecc:conc time ratio"
    - "Movement smoothness contributes up to 20 points based on velocity variance"
    - "First rep of a set scores 100 (no baseline to compare against)"
    - "Quality trend (improving/stable/declining) is computed from rep score sequence"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/RepQuality.kt"
      provides: "RepQualityScore data class, QualityTrend enum, SetQualitySummary"
      min_lines: 30
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/RepQualityScorer.kt"
      provides: "Stateful scorer that accumulates per-set baselines and scores each rep"
      exports: ["RepQualityScorer"]
    - path: "shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/RepQualityScorerTest.kt"
      provides: "Unit tests for all four scoring components and edge cases"
      min_lines: 80
  key_links:
    - from: "RepQualityScorer"
      to: "RepMetricData"
      via: "scoreRep() accepts RepMetricData and returns RepQualityScore"
      pattern: "fun scoreRep.*RepMetricData.*RepQualityScore"
    - from: "RepQualityScorer"
      to: "RunningAverage"
      via: "Uses RunningAverage for ROM and velocity baselines"
      pattern: "RunningAverage"
---

<objective>
Build the RepQualityScorer engine using TDD -- a pure domain class that scores each rep 0-100 based on four weighted components (ROM 30pts, velocity 25pts, eccentric control 25pts, smoothness 20pts).

Purpose: This is the core scoring algorithm that all UI features depend on. TDD ensures the math is correct before any integration work.
Output: RepQualityScorer class with full test coverage, RepQuality domain models.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/RepMetrics.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/util/RunningAverage.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/FeatureGate.kt
</context>

<feature>
  <name>RepQualityScorer Engine</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/RepQuality.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/RepQualityScorer.kt
    shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/RepQualityScorerTest.kt
  </files>
  <behavior>
    RepQualityScorer is a stateful class that accumulates baselines per set.

    Domain models (RepQuality.kt):
    - RepQualityScore: data class with composite (Int 0-100), romScore (Float 0-30), velocityScore (Float 0-25),
      eccentricControlScore (Float 0-25), smoothnessScore (Float 0-20), repNumber (Int)
    - QualityTrend: enum IMPROVING, STABLE, DECLINING
    - SetQualitySummary: data class with averageScore (Int), bestScore (Int), worstScore (Int),
      bestRepNumber (Int), worstRepNumber (Int), trend (QualityTrend), repScores (List of RepQualityScore)

    RepQualityScorer (in domain/premium/ alongside FeatureGate):
    - Constructor: no dependencies (pure domain logic)
    - State: RunningAverage for ROM and velocity baselines, list of scored reps
    - fun reset(): clears all state for new set
    - fun scoreRep(repData: RepMetricData): RepQualityScore
    - fun getSetSummary(): SetQualitySummary
    - fun getTrend(): QualityTrend

    Scoring algorithm for scoreRep():
    1. ROM Score (0-30): First rep = 30. Subsequent reps: deviation = |repROM - avgROM| / avgROM.
       Score = 30 * max(0, 1 - deviation * 3). Clamp to [0, 30]. Then add repROM to running average.
    2. Velocity Score (0-25): Same pattern using avgVelocityConcentric. First rep = 25.
       Score = 25 * max(0, 1 - deviation * 3). Clamp to [0, 25].
    3. Eccentric Control (0-25): ratio = eccentricDurationMs / concentricDurationMs.
       Ideal ratio = 2.0 (eccentric should be ~2x concentric). Score = 25 * max(0, 1 - |ratio - 2.0| / 2.0).
       Clamp to [0, 25]. If concentricDurationMs == 0, score = 0.
    4. Smoothness (0-20): Compute variance of concentricVelocities array.
       Normalize: coeffOfVariation = sqrt(variance) / mean(concentricVelocities).
       Score = 20 * max(0, 1 - coeffOfVariation * 2). Clamp to [0, 20].
       If array empty or mean == 0, score = 10 (neutral).

    composite = round(romScore + velocityScore + eccentricControlScore + smoothnessScore).toInt().coerceIn(0, 100)

    Trend calculation (getTrend()):
    - Needs >= 3 reps. Split scores into first half and second half.
    - If second half average > first half average + 5: IMPROVING
    - If second half average < first half average - 5: DECLINING
    - Otherwise: STABLE

    Cases:
    - First rep -> RepQualityScore(100, 30, 25, 25, 20, repNumber=1) (perfect baseline)
      EXCEPT eccentric control and smoothness are still computed from actual data
    - Consistent reps (same ROM, velocity) -> scores near 90-100
    - Declining ROM by 20% -> ROM component drops to ~12/30
    - Very fast eccentric (ratio 0.5) -> eccentric control score ~6/25
    - Erratic velocity array -> smoothness score drops
    - 5 reps declining quality -> trend = DECLINING
  </behavior>
  <implementation>
    RED: Write tests first covering:
    1. First rep returns perfect ROM + velocity scores (eccentric/smoothness computed normally)
    2. Consistent reps maintain high composite scores
    3. ROM deviation penalizes ROM component correctly
    4. Velocity deviation penalizes velocity component
    5. Eccentric ratio at 2.0 gives full 25 points
    6. Eccentric ratio at 0.5 gives low score
    7. Smooth velocity array gives high smoothness score
    8. Erratic velocity array gives low smoothness score
    9. Trend detects IMPROVING pattern
    10. Trend detects DECLINING pattern
    11. Trend returns STABLE for consistent scores
    12. SetSummary computes correct averageScore, bestScore, worstScore
    13. reset() clears all state

    GREEN: Implement RepQuality.kt models, then RepQualityScorer with the algorithm above.

    REFACTOR: Extract component scoring into internal helper methods if the scoreRep method exceeds ~40 lines.
  </implementation>
</feature>

<verification>
- `./gradlew :shared:testDebugUnitTest --tests "com.devil.phoenixproject.domain.premium.RepQualityScorerTest"` passes
- All 13+ tests pass
- `./gradlew :shared:compileCommonMainKotlinMetadata` compiles cleanly
</verification>

<success_criteria>
- RepQualityScorer.scoreRep() returns correct scores for all four components
- First rep scores are handled correctly (perfect baseline for ROM/velocity)
- Trend detection works for improving, stable, and declining patterns
- SetQualitySummary aggregates correctly
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-rep-quality-scoring/03-01-SUMMARY.md`
</output>
