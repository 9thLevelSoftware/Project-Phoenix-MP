---
phase: 04-smart-suggestions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/src/commonMain/sqldelight/com/devil/phoenixproject/database/VitruvianDatabase.sq
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/SmartSuggestionsRepository.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/di/DataModule.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/subscription/SubscriptionManager.kt
autonomous: true
must_haves:
  truths:
    - "Repository can query session summaries joining WorkoutSession with Exercise for muscle group data"
    - "SubscriptionManager exposes hasEliteAccess flow for Elite tier gating"
    - "SmartSuggestionsRepository is registered in Koin DI"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/SmartSuggestionsRepository.kt"
      provides: "Repository interface and SQLDelight implementation for session summary queries"
      exports: ["SmartSuggestionsRepository", "SqlDelightSmartSuggestionsRepository"]
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/subscription/SubscriptionManager.kt"
      provides: "Updated SubscriptionManager with hasEliteAccess flow"
      contains: "hasEliteAccess"
  key_links:
    - from: "SmartSuggestionsRepository"
      to: "VitruvianDatabase.sq"
      via: "SQLDelight generated queries"
      pattern: "selectSessionSummaries"
    - from: "SubscriptionManager"
      to: "SubscriptionTier"
      via: "FeatureGate.isEnabled check"
      pattern: "ELITE"
---

<objective>
Create the data layer for smart suggestions: SQL queries for session-exercise joins, a repository to serve session summaries to the engine, and add Elite tier access flow to SubscriptionManager.

Purpose: Bridge the gap between raw DB data and the pure computation engine (Plan 01), and enable Elite tier gating (GATE-03/SUGG-06).
Output: SmartSuggestionsRepository + hasEliteAccess on SubscriptionManager.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@shared/src/commonMain/sqldelight/com/devil/phoenixproject/database/VitruvianDatabase.sq
@shared/src/commonMain/kotlin/com/devil/phoenixproject/di/DataModule.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/subscription/SubscriptionManager.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/FeatureGate.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/SubscriptionTier.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SQL queries and SmartSuggestionsRepository</name>
  <files>
    shared/src/commonMain/sqldelight/com/devil/phoenixproject/database/VitruvianDatabase.sq
    shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/SmartSuggestionsRepository.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/di/DataModule.kt
  </files>
  <action>
    1. Add SQL query to VitruvianDatabase.sq that joins WorkoutSession with Exercise to produce session summaries:

    ```sql
    -- Smart Suggestions: session summaries with exercise muscle group data
    selectSessionSummariesSince:
    SELECT ws.exerciseId, ws.exerciseName, e.muscleGroup, ws.timestamp,
           ws.weightPerCableKg, ws.totalReps, ws.workingReps
    FROM WorkoutSession ws
    LEFT JOIN Exercise e ON ws.exerciseId = e.id
    WHERE ws.exerciseId IS NOT NULL
      AND ws.timestamp > ?
    ORDER BY ws.timestamp DESC;
    ```

    Also add a query for exercise last-performed dates (for neglect detection):
    ```sql
    selectExerciseLastPerformed:
    SELECT e.id AS exerciseId, e.name AS exerciseName, e.muscleGroup,
           MAX(ws.timestamp) AS lastPerformed
    FROM Exercise e
    INNER JOIN WorkoutSession ws ON ws.exerciseId = e.id
    WHERE e.archived = 0
    GROUP BY e.id;
    ```

    Also add a query for per-exercise weight history (for plateau detection):
    ```sql
    selectExerciseWeightHistory:
    SELECT ws.exerciseId, ws.exerciseName, ws.weightPerCableKg, ws.timestamp
    FROM WorkoutSession ws
    WHERE ws.exerciseId IS NOT NULL
    ORDER BY ws.exerciseId, ws.timestamp ASC;
    ```

    2. Create SmartSuggestionsRepository.kt in data/repository/:

    ```kotlin
    interface SmartSuggestionsRepository {
        suspend fun getSessionSummariesSince(sinceTimestamp: Long): List<SessionSummary>
        suspend fun getExerciseLastPerformed(): List<SessionSummary>  // reuse model, only exerciseId/name/muscleGroup/timestamp populated
        suspend fun getExerciseWeightHistory(): List<SessionSummary>  // reuse model, only exerciseId/name/weight/timestamp populated
    }
    ```

    The SqlDelight implementation maps DB rows to SessionSummary domain model (from SmartSuggestions.kt in Plan 01). If Plan 01 hasn't executed yet, define the SessionSummary model inline or import from the domain model file.

    Handle NULL muscleGroup from LEFT JOIN by defaulting to exerciseName or "Unknown".
    Handle NULL fields gracefully (exercises without IDs are already filtered by WHERE clause).

    3. Register in DataModule.kt:
    ```kotlin
    single<SmartSuggestionsRepository> { SqlDelightSmartSuggestionsRepository(get()) }
    ```
  </action>
  <verify>
    `./gradlew :shared:compileDebugKotlinAndroid` succeeds (SQLDelight generates query code).
    Koin module verify test still passes: `./gradlew :shared:testDebugUnitTest --tests "*.KoinModuleVerifyTest"`
  </verify>
  <done>
    - 3 SQL queries added to VitruvianDatabase.sq
    - SmartSuggestionsRepository interface and implementation created
    - DI registered in DataModule
    - Project compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Add hasEliteAccess to SubscriptionManager</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/subscription/SubscriptionManager.kt
  </files>
  <action>
    Add a `hasEliteAccess` StateFlow to SubscriptionManager alongside the existing `hasProAccess`.

    The current implementation watches `userProfileRepository.getActiveProfileSubscriptionStatus()` and sets `_isProSubscriber` when status == ACTIVE.

    Problem: Current SubscriptionManager only has binary Pro/not-Pro. It reads `subscription_status` from UserProfile (stored as "free", "phoenix", "elite" strings). But the SubscriptionStatus enum from the repository may not distinguish Phoenix from Elite.

    Implementation approach:
    1. Check what `getActiveProfileSubscriptionStatus()` returns. It likely returns a Flow of SubscriptionStatus enum or string.
    2. Add a `_isEliteSubscriber` MutableStateFlow alongside `_isProSubscriber`.
    3. In the init collector, determine tier from the status string:
       - Map "elite" -> both Pro and Elite access
       - Map "phoenix" or "active" -> Pro but not Elite
       - Map "free" or other -> neither
    4. Expose `val hasEliteAccess: StateFlow<Boolean> = _isEliteSubscriber.asStateFlow()`

    If the existing SubscriptionStatus enum is just ACTIVE/INACTIVE (no tier distinction), use the UserProfile's `subscription_status` field directly. The UserProfile table has `subscription_status TEXT DEFAULT 'free'` which stores "free", "phoenix", or "elite" per the SubscriptionTier enum.

    Add a `getActiveProfileTier()` method to the repository if needed, or use the existing `getActiveProfileSubscriptionStatus()` and compare against SubscriptionTier.fromDbString().

    Keep backward compatibility: hasProAccess should remain true for both Phoenix AND Elite tiers.
  </action>
  <verify>
    `./gradlew :shared:compileDebugKotlinAndroid` succeeds.
    Verify hasEliteAccess is accessible: grep for "hasEliteAccess" in the compiled output.
  </verify>
  <done>
    - SubscriptionManager has `hasEliteAccess: StateFlow<Boolean>` that is true only for Elite tier
    - `hasProAccess` remains true for both Phoenix and Elite (backward compatible)
    - No compilation errors
  </done>
</task>

</tasks>

<verification>
```bash
./gradlew :shared:compileDebugKotlinAndroid
./gradlew :shared:testDebugUnitTest --tests "*.KoinModuleVerifyTest"
```
Both pass. SmartSuggestionsRepository registered, SubscriptionManager has Elite flow.
</verification>

<success_criteria>
- SQL queries compile and generate correct SQLDelight code
- SmartSuggestionsRepository provides session data joined with exercise muscle groups
- SubscriptionManager.hasEliteAccess returns true only for ELITE tier users
- Koin verify test passes with new repository registered
</success_criteria>

<output>
After completion, create `.planning/phases/04-smart-suggestions/04-02-SUMMARY.md`
</output>
