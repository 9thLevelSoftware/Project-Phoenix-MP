---
phase: 10-strength-assessment
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/assessment/AssessmentEngine.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/assessment/AssessmentModels.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/assessment/AssessmentEngineTest.kt
autonomous: true

must_haves:
  truths:
    - "Load-velocity linear regression produces an estimated 1RM from at least 2 load/velocity data points"
    - "Velocity threshold detection identifies when mean concentric velocity drops below 0.3 m/s"
    - "Regression handles edge cases: identical velocities, single data point, negative slope"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/assessment/AssessmentModels.kt"
      provides: "LoadVelocityPoint, AssessmentSet, AssessmentState, AssessmentResult domain models"
      min_lines: 40
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/assessment/AssessmentEngine.kt"
      provides: "Load-velocity regression, 1RM estimation, velocity threshold detection"
      exports: ["AssessmentEngine"]
    - path: "shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/assessment/AssessmentEngineTest.kt"
      provides: "Unit tests for regression accuracy, threshold detection, edge cases"
      min_lines: 80
  key_links:
    - from: "AssessmentEngine"
      to: "AssessmentModels"
      via: "direct import"
      pattern: "LoadVelocityPoint|AssessmentResult"
---

<objective>
Create the pure domain engine for VBT-based strength assessment with load-velocity linear regression and velocity threshold detection.

Purpose: This engine is the core algorithm that estimates a user's 1RM from progressive-weight sets by fitting a linear regression to load vs. mean concentric velocity data points and extrapolating to the velocity at which 1RM occurs (~0.15-0.2 m/s for most exercises).

Output: Tested domain logic with no UI or database dependencies.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/BiomechanicsModels.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/Models.kt
</context>

<feature>
  <name>Assessment Engine: Load-Velocity Regression and 1RM Estimation</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/assessment/AssessmentModels.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/assessment/AssessmentEngine.kt
    shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/assessment/AssessmentEngineTest.kt
  </files>
  <behavior>
    AssessmentModels.kt defines:
    - LoadVelocityPoint(loadKg: Float, meanVelocityMs: Float) — a single data point from one set
    - AssessmentSetResult(setNumber: Int, loadKg: Float, reps: Int, meanVelocityMs: Float, peakVelocityMs: Float) — result of one assessment set
    - AssessmentResult(estimatedOneRepMaxKg: Float, loadVelocityPoints: List<LoadVelocityPoint>, r2: Float, velocityAt1RM: Float) — final assessment output
    - AssessmentConfig(minSets: Int = 2, maxSets: Int = 5, velocityThresholdMs: Float = 0.3f, oneRmVelocityMs: Float = 0.17f, startingWeightPercent: Float = 0.4f, weightIncrementKg: Float = 10f) — configurable parameters

    AssessmentEngine provides:
    - estimateOneRepMax(points: List<LoadVelocityPoint>, config: AssessmentConfig = AssessmentConfig()): AssessmentResult?
      - Performs ordinary least squares linear regression: velocity = slope * load + intercept
      - Extrapolates load at velocity = config.oneRmVelocityMs (default 0.17 m/s)
      - Returns null if fewer than config.minSets points
      - Returns null if slope >= 0 (velocity should decrease with increasing load)
      - Computes R-squared for regression quality
    - shouldStopAssessment(latestVelocity: Float, config: AssessmentConfig = AssessmentConfig()): Boolean
      - Returns true if latestVelocity <= config.velocityThresholdMs (default 0.3 m/s)
    - suggestNextWeight(currentLoadKg: Float, currentVelocity: Float, config: AssessmentConfig = AssessmentConfig()): Float
      - If currentVelocity > 0.8 m/s: increment by 2x config.weightIncrementKg (large jump for very light sets)
      - If currentVelocity > 0.5 m/s: increment by config.weightIncrementKg (standard jump)
      - If currentVelocity > 0.3 m/s: increment by config.weightIncrementKg / 2 (small jump, approaching threshold)
      - Else: return currentLoadKg (at threshold, no more sets needed)
      - Result clamped to 0.5kg increments (machine resolution) and max 220kg

    Test cases (input -> expected output):
    - 2 points [(40kg, 1.2m/s), (80kg, 0.6m/s)]: regression slope = -0.015, intercept = 1.8, 1RM at 0.17m/s ~ 108.7kg
    - 3 points [(30kg, 1.3m/s), (60kg, 0.8m/s), (90kg, 0.3m/s)]: extrapolate to ~0.17m/s, should be ~96-98kg range
    - 1 point only: returns null (insufficient data)
    - Points with positive slope [(40kg, 0.5m/s), (80kg, 0.8m/s)]: returns null (invalid - velocity should drop)
    - shouldStopAssessment(0.25f): true
    - shouldStopAssessment(0.35f): false
    - suggestNextWeight(40f, 1.0f): 60f (large jump)
    - suggestNextWeight(80f, 0.45f): 85f (small jump)
  </behavior>
  <implementation>
    Follow the BiomechanicsEngine pattern: pure class with no dependencies, stateless computation methods. Place in domain/assessment/ package alongside models. Use standard OLS regression formula:
    slope = (n*sum(xy) - sum(x)*sum(y)) / (n*sum(x^2) - sum(x)^2)
    intercept = (sum(y) - slope*sum(x)) / n
    R^2 = 1 - SS_res / SS_tot

    Tests use kotlin.test (same as existing test infrastructure). Verify regression accuracy within +/- 2kg tolerance for computed 1RM values.
  </implementation>
</feature>

<verification>
- `./gradlew :shared:testDebugUnitTest --tests "*.AssessmentEngineTest"` passes all tests
- Tests cover: valid 2-point regression, valid 3+ point regression, insufficient data, invalid slope, threshold detection, weight suggestions
</verification>

<success_criteria>
- AssessmentEngine.estimateOneRepMax produces accurate 1RM estimates (within 2kg of hand-calculated values) from load-velocity data
- shouldStopAssessment correctly identifies when velocity drops below threshold
- suggestNextWeight provides reasonable progressive increments
- All edge cases handled gracefully (null returns, not crashes)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-strength-assessment/10-01-SUMMARY.md`
</output>
