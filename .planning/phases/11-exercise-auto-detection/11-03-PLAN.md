---
phase: 11-exercise-auto-detection
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ExerciseDetectionManager.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/components/AutoDetectionSheet.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ActiveSessionEngine.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/screen/WorkoutHud.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/di/PresentationModule.kt
autonomous: true

must_haves:
  truths:
    - "After 3-5 reps of a set, the system suggests an exercise name with confidence percentage via a non-blocking bottom sheet"
    - "User can confirm the suggestion or select a different exercise without interrupting the workout"
    - "Confirmed exercise signatures are stored and used to improve future suggestions"
    - "Repeat performances of the same exercise produce higher confidence scores over time"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ExerciseDetectionManager.kt"
      provides: "Orchestrates detection flow: collects metrics, triggers extraction, manages UI state"
      contains: "class ExerciseDetectionManager"
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/components/AutoDetectionSheet.kt"
      provides: "Bottom sheet UI for exercise suggestion confirmation"
      contains: "@Composable"
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt"
      provides: "Integration point that triggers detection after rep threshold"
      contains: "detectionManager"
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/screen/WorkoutHud.kt"
      provides: "Renders AutoDetectionSheet overlay during active workout"
      contains: "AutoDetectionSheet"
  key_links:
    - from: "ActiveSessionEngine"
      to: "ExerciseDetectionManager"
      via: "onRepCompleted triggers detection check"
      pattern: "detectionManager.*onRep"
    - from: "ExerciseDetectionManager"
      to: "SignatureExtractor"
      via: "extractSignature from collected metrics"
      pattern: "signatureExtractor.*extractSignature"
    - from: "ExerciseDetectionManager"
      to: "ExerciseSignatureRepository"
      via: "saveSignature on confirmation"
      pattern: "signatureRepository.*save"
    - from: "WorkoutHud"
      to: "AutoDetectionSheet"
      via: "conditional rendering when detection state is active"
      pattern: "AutoDetectionSheet"
---

<objective>
Integrate exercise auto-detection into the active workout flow with a non-blocking bottom sheet for confirmation.

Purpose: This plan connects the domain detection engine (Plan 01) and repository (Plan 02) to the workout UI. After 3-5 reps, the system analyzes movement, suggests an exercise, and lets the user confirm or correct -- all without interrupting the workout. Confirmed selections evolve the signature for better future accuracy (DETECT-03, DETECT-04, DETECT-06).

Output: Working end-to-end auto-detection flow during workouts.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-exercise-auto-detection/11-01-SUMMARY.md
@.planning/phases/11-exercise-auto-detection/11-02-SUMMARY.md
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ActiveSessionEngine.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/screen/WorkoutHud.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/screen/ExerciseEditBottomSheet.kt (reference for bottom sheet pattern)
@shared/src/commonMain/kotlin/com/devil/phoenixproject/di/PresentationModule.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: ExerciseDetectionManager and workout flow integration</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ExerciseDetectionManager.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ActiveSessionEngine.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/di/PresentationModule.kt
  </files>
  <action>
**ExerciseDetectionManager.kt** -- New manager class in `presentation/manager/`:

```kotlin
class ExerciseDetectionManager(
    private val signatureExtractor: SignatureExtractor,
    private val exerciseClassifier: ExerciseClassifier,
    private val signatureRepository: ExerciseSignatureRepository,
    private val exerciseRepository: ExerciseRepository
)
```

**State exposed via StateFlow:**

```kotlin
data class DetectionState(
    val isActive: Boolean = false,           // whether detection sheet should show
    val classification: ExerciseClassification? = null,
    val signature: ExerciseSignature? = null, // current extracted signature
    val isDismissed: Boolean = false          // user dismissed without confirming
)

private val _detectionState = MutableStateFlow(DetectionState())
val detectionState: StateFlow<DetectionState> = _detectionState
```

**Key methods:**

`fun onRepCompleted(repNumber: Int, metrics: List<WorkoutMetric>, scope: CoroutineScope)`:
- Only trigger once per set (use a `hasTriggeredThisSet: Boolean` flag)
- Only trigger when repNumber reaches 3 (configurable MIN_REPS_FOR_DETECTION = 3)
- Only trigger if the current workout does NOT already have an exercise assigned (check via a flag or the workout parameters)
- Launch in provided scope on Dispatchers.Default:
  1. Extract signature: `signatureExtractor.extractSignature(metrics)`
  2. If null (insufficient data), return silently
  3. Load history: `signatureRepository.getAllSignaturesAsMap()`
  4. Classify: `exerciseClassifier.classify(signature, history)`
  5. Update state: `_detectionState.value = DetectionState(isActive = true, classification = result, signature = extractedSig)`

`suspend fun onExerciseConfirmed(exerciseId: String, exerciseName: String)`:
- Get the current extracted signature from state
- Check if a stored signature exists for this exerciseId via `signatureRepository.getSignaturesByExercise(exerciseId)`
- If exists: evolve using `exerciseClassifier.evolveSignature(existing, newSignature)`, then `signatureRepository.updateSignature(existingId, evolved)`
- If not exists: `signatureRepository.saveSignature(exerciseId, newSignature)`
- Clear detection state: `_detectionState.value = DetectionState()`
- Return the exerciseId so the caller can update the workout session

`fun onDetectionDismissed()`:
- Set `_detectionState.value = DetectionState(isDismissed = true)`
- Detection will not re-trigger for this set

`fun resetForNewSet()`:
- Reset `hasTriggeredThisSet = false`, clear state

**Integration into ActiveSessionEngine.kt:**

Add `ExerciseDetectionManager` as a constructor parameter (injected via Koin through WorkoutCoordinator or directly).

In the rep counting section where `RepType.WORKING_COMPLETED` events are processed (around the `scoreCurrentRep` call area), add after rep scoring:

```kotlin
// Exercise auto-detection: trigger after MIN_REPS working reps
if (repEvent.type == RepType.WORKING_COMPLETED) {
    detectionManager?.onRepCompleted(
        repNumber = coordinator._repCount.value.workingReps,
        metrics = coordinator.collectedMetrics.toList(),
        scope = scope
    )
}
```

The `detectionManager` should be nullable -- only provided when detection feature is enabled (Elite tier). For now, always inject it; tier gating will be handled at the UI layer.

**Integration into DefaultWorkoutSessionManager.kt:**

- Add `ExerciseDetectionManager` as constructor parameter
- Pass it to `ActiveSessionEngine` constructor
- Expose `detectionManager.detectionState` as a public property for UI consumption
- In `proceedFromSummary()` (set transition), call `detectionManager.resetForNewSet()`
- In the workout completion flow, call `detectionManager.resetForNewSet()`

**PresentationModule.kt:**

Add factory binding:
```kotlin
factory { ExerciseDetectionManager(get(), get(), get(), get()) }
```

Update `MainViewModel` factory if it needs the detection state flow exposed. However, since DefaultWorkoutSessionManager already exposes it, the UI can access it through the existing manager chain. Check how WorkoutHud currently gets its state -- it likely receives it from MainViewModel or directly from the manager. Follow the existing pattern.

Also update the DefaultWorkoutSessionManager Koin binding if needed (it's currently constructed inline in MainViewModel or similar -- check and add the new parameter).

**IMPORTANT**: The ActiveSessionEngine's rep event handling is in `handleRepNotification()` or similar. Find where `RepType.WORKING_COMPLETED` is processed and add the detection trigger there. Do NOT modify the RepCounterFromMachine -- detection hooks into the event flow, not the counter itself.
  </action>
  <verify>
`./gradlew :androidApp:assembleDebug` compiles without errors.
  </verify>
  <done>ExerciseDetectionManager orchestrates detection flow. ActiveSessionEngine triggers detection after 3 working reps. DefaultWorkoutSessionManager exposes detection state. All wired through Koin.</done>
</task>

<task type="auto">
  <name>Task 2: Auto-detection bottom sheet UI and WorkoutHud integration</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/components/AutoDetectionSheet.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/screen/WorkoutHud.kt
  </files>
  <action>
**AutoDetectionSheet.kt** -- New Composable in `presentation/components/`:

A non-blocking bottom sheet overlay that appears during an active workout. Must NOT block the workout UI -- the user should still see the HUD and continue exercising.

```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AutoDetectionSheet(
    classification: ExerciseClassification,
    onConfirm: (exerciseId: String, exerciseName: String) -> Unit,
    onSelectDifferent: () -> Unit,
    onDismiss: () -> Unit,
    exercises: List<Exercise>,  // for "select different" picker
    modifier: Modifier = Modifier
)
```

**Layout (per Spec 04 Section 4.3):**

Use `ModalBottomSheet` with `skipPartiallyExpanded = false` so it starts at partial height (non-blocking).

Content:
1. **Header**: "Exercise Detected" with an icon (Icons.Default.FitnessCenter or similar)
2. **Primary suggestion**: Large text showing `classification.exerciseName` with confidence as a percentage badge (e.g., "87%"). Use color coding: green >80%, yellow 60-80%, orange <60%.
3. **Alternates**: If `classification.alternates` is not empty, show "Did you mean?" with clickable chips for each alternate exercise name
4. **Action buttons**:
   - "Confirm" button (filled, primary) -- calls `onConfirm(classification.exerciseId ?: "", classification.exerciseName)`
   - "Select Different" button (outlined) -- opens a simple exercise search/list within the sheet
   - Dismiss (X button or swipe down) -- calls `onDismiss()`
5. **"Select Different" mode**: When activated, show a `TextField` search field and a filtered list of exercises from the `exercises` parameter. Tapping an exercise calls `onConfirm(exercise.id, exercise.name)`.

Use Material3 theming consistent with the rest of the app. Follow the bottom sheet patterns in `ExerciseEditBottomSheet.kt` for reference (ModalBottomSheetState, rememberModalBottomSheetState).

**WorkoutHud.kt integration:**

Find the main `WorkoutHud` composable. It receives workout state from the ViewModel/Manager chain.

Add detection state observation:
```kotlin
val detectionState by detectionManager.detectionState.collectAsState()
```

Or receive it as a parameter -- follow whichever pattern WorkoutHud uses for other state (it likely receives state via parameters from `ActiveWorkoutScreen`).

Add conditional rendering at the end of the WorkoutHud composable (overlay, not replacing content):

```kotlin
if (detectionState.isActive && detectionState.classification != null && !detectionState.isDismissed) {
    AutoDetectionSheet(
        classification = detectionState.classification!!,
        onConfirm = { exerciseId, name ->
            scope.launch {
                detectionManager.onExerciseConfirmed(exerciseId, name)
                // Update the current workout session's exercise
                workoutSessionManager.updateCurrentExercise(exerciseId, name)
            }
        },
        onSelectDifferent = { /* handled inside sheet */ },
        onDismiss = { detectionManager.onDetectionDismissed() },
        exercises = allExercises  // from existing exercise list state
    )
}
```

**IMPORTANT**: Trace how WorkoutHud receives its parameters. It may be called from `ActiveWorkoutScreen.kt`. If so, add the detection state and callbacks as parameters to WorkoutHud and wire them in ActiveWorkoutScreen. Follow the existing parameter passing pattern -- do NOT introduce new global state or direct Koin injection in composables (use the ViewModel/Manager chain).

If `updateCurrentExercise` doesn't exist on DefaultWorkoutSessionManager, add a simple method that updates the coordinator's current exercise tracking and persists via exerciseRepository/workoutRepository.
  </action>
  <verify>
`./gradlew :androidApp:assembleDebug` compiles without errors.

Verify the composable exists and is reachable: search for `AutoDetectionSheet` in WorkoutHud.kt to confirm it's wired in.
  </verify>
  <done>AutoDetectionSheet shows exercise suggestion with confidence percentage as a non-blocking bottom sheet during workout. User can confirm (stores/evolves signature), select a different exercise (with search), or dismiss. WorkoutHud renders the sheet when detection state is active.</done>
</task>

</tasks>

<verification>
- `./gradlew :androidApp:assembleDebug` compiles without errors
- ExerciseDetectionManager triggers after 3 working reps with collected metrics
- AutoDetectionSheet renders classification with confidence percentage
- Confirming an exercise saves/evolves the signature in ExerciseSignatureRepository
- Dismissing prevents re-triggering for the same set
- Set transitions reset detection state
- Detection flow is non-blocking -- workout continues uninterrupted
</verification>

<success_criteria>
End-to-end auto-detection works: after 3 reps the system extracts a signature, classifies it, shows a non-blocking bottom sheet with the suggestion and confidence, and persists the confirmed signature for future improved matching. The workout is never interrupted.
</success_criteria>

<output>
After completion, create `.planning/phases/11-exercise-auto-detection/11-03-SUMMARY.md`
</output>
