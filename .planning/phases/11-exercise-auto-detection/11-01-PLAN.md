---
phase: 11-exercise-auto-detection
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/detection/DetectionModels.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/detection/SignatureExtractor.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/detection/ExerciseClassifier.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/detection/SignatureExtractorTest.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/detection/ExerciseClassifierTest.kt
autonomous: true

must_haves:
  truths:
    - "SignatureExtractor produces an ExerciseSignature from 3-5 reps of WorkoutMetric data"
    - "ExerciseClassifier returns an ExerciseClassification with confidence percentage from a signature"
    - "History matching produces higher confidence than rule-based classification"
    - "Weighted similarity uses ROM 40%, duration 20%, symmetry 25%, shape 15%"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/detection/DetectionModels.kt"
      provides: "ExerciseSignature, ExerciseClassification, VelocityShape, CableUsage data classes"
      contains: "data class ExerciseSignature"
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/detection/SignatureExtractor.kt"
      provides: "Extracts movement signature from WorkoutMetric list"
      exports: ["SignatureExtractor"]
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/detection/ExerciseClassifier.kt"
      provides: "Rule-based + history-based exercise classification"
      exports: ["ExerciseClassifier"]
    - path: "shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/detection/SignatureExtractorTest.kt"
      provides: "Unit tests for signature extraction"
      min_lines: 50
    - path: "shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/detection/ExerciseClassifierTest.kt"
      provides: "Unit tests for classification"
      min_lines: 50
  key_links:
    - from: "SignatureExtractor"
      to: "WorkoutMetric"
      via: "extractSignature(metrics: List<WorkoutMetric>)"
      pattern: "fun extractSignature.*List<WorkoutMetric>"
    - from: "ExerciseClassifier"
      to: "ExerciseSignature"
      via: "classify(signature, history)"
      pattern: "fun classify.*ExerciseSignature"
---

<objective>
Create the signature extraction engine and rule-based classifier for exercise auto-detection using TDD.

Purpose: DETECT-01 (signature extraction) and DETECT-02 (rule-based classifier with history matching) are pure business logic with well-defined inputs/outputs -- ideal TDD candidates. This plan establishes the domain-layer intelligence that powers auto-detection.

Output: Tested SignatureExtractor and ExerciseClassifier classes with domain models.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/specs/04-platform-features.md (Section 4: Exercise Auto-Detection)
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/Models.kt (WorkoutMetric at line 269)
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/Exercise.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Domain models and SignatureExtractor with tests (TDD)</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/detection/DetectionModels.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/detection/SignatureExtractor.kt
    shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/detection/SignatureExtractorTest.kt
  </files>
  <action>
**RED phase first -- write tests, then GREEN.**

**DetectionModels.kt** -- Create in `domain/detection/` package:

```kotlin
enum class VelocityShape { EXPLOSIVE_START, LINEAR, DECELERATING }

enum class CableUsage { SINGLE_LEFT, SINGLE_RIGHT, DUAL_SYMMETRIC, DUAL_ASYMMETRIC }

data class ExerciseSignature(
    val romMm: Float,              // peak position - rest position (averaged across reps)
    val durationMs: Long,          // average rep duration in ms
    val symmetryRatio: Float,      // loadA / (loadA + loadB), 0.5 = symmetric
    val velocityProfile: VelocityShape,
    val cableConfig: CableUsage,
    val sampleCount: Int = 1,      // how many observations contributed
    val confidence: Float = 0f     // aggregated confidence (0.0-1.0)
)

data class ExerciseClassification(
    val exerciseId: String?,       // null if rule-based only
    val exerciseName: String,
    val confidence: Float,         // 0.0 to 1.0
    val alternates: List<String>,  // other likely exercises
    val source: ClassificationSource
)

enum class ClassificationSource { HISTORY_MATCH, RULE_BASED }
```

**SignatureExtractor.kt** -- Pure function, no dependencies:

```kotlin
class SignatureExtractor {
    fun extractSignature(metrics: List<WorkoutMetric>): ExerciseSignature?
}
```

Implementation details:
- Return null if fewer than 30 metrics (not enough data for ~3 reps at 10Hz)
- **ROM**: Find position valleys (local minima in positionA) using smoothed data. ROM = average (peak - valley) across detected reps. Use a 5-sample moving average for smoothing, then detect valleys where value is lower than both neighbors by at least 10mm.
- **Duration**: Average time between consecutive valleys (rep boundaries)
- **Symmetry**: `mean(loadA) / (mean(loadA) + mean(loadB))`. If loadB is always < 1.0kg, classify as single cable.
- **Cable usage**: SINGLE_LEFT if loadB always < 1kg, SINGLE_RIGHT if loadA always < 1kg, DUAL_SYMMETRIC if symmetry in 0.4-0.6, DUAL_ASYMMETRIC otherwise
- **Velocity profile**: Divide first detected rep's concentric phase (valley to peak) into thirds. If first third has highest avg velocity -> EXPLOSIVE_START. If roughly equal -> LINEAR. If last third lowest -> DECELERATING.

**Tests (RED first):**
- `extractSignature returns null for insufficient data` (< 30 samples)
- `extractSignature calculates ROM from position valleys` (provide synthetic metrics with known positions: 100, 200, 300, 200, 100, 200, 300... -> ROM ~200mm)
- `extractSignature detects single cable usage` (loadB always 0)
- `extractSignature detects dual symmetric usage` (loadA ~= loadB)
- `extractSignature calculates rep duration from valley timing` (valleys at t=0, t=2000, t=4000 -> ~2000ms)
- `extractSignature classifies velocity profile` (provide metrics with decreasing velocity -> DECELERATING)

Commit RED: `test(11-01): add failing SignatureExtractor tests`
Commit GREEN: `feat(11-01): implement SignatureExtractor with valley-based rep detection`
  </action>
  <verify>
Run `./gradlew :shared:testDebugUnitTest --tests "com.devil.phoenixproject.domain.detection.SignatureExtractorTest"` -- all tests pass.
  </verify>
  <done>SignatureExtractor produces correct ExerciseSignature from synthetic WorkoutMetric data, with all 6+ test cases passing.</done>
</task>

<task type="auto">
  <name>Task 2: ExerciseClassifier with history matching and tests (TDD)</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/detection/ExerciseClassifier.kt
    shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/detection/ExerciseClassifierTest.kt
  </files>
  <action>
**RED phase first -- write tests, then GREEN.**

**ExerciseClassifier.kt:**

```kotlin
class ExerciseClassifier {
    fun classify(
        signature: ExerciseSignature,
        history: Map<String, ExerciseSignature>  // exerciseId -> stored signature
    ): ExerciseClassification

    fun computeSimilarity(a: ExerciseSignature, b: ExerciseSignature): Float

    fun evolveSignature(
        existing: ExerciseSignature,
        newObservation: ExerciseSignature,
        alpha: Float = 0.3f
    ): ExerciseSignature
}
```

**classify() logic** (per Spec 04 Section 4.2):
1. First check history matches using `computeSimilarity()`. If best match > 0.85 -> return HISTORY_MATCH with that exercise.
2. Fall back to rule-based classification using decision tree:
   - Single cable + short ROM (<300mm) -> Bicep Curl (0.6 confidence)
   - Single cable + medium ROM (300-500mm) -> Lateral Raise (0.5)
   - Single cable + long ROM (>500mm) -> Single Arm Row (0.5)
   - Dual symmetric + short ROM (<400mm) + fast (<3000ms) + explosive -> Chest Press (0.7)
   - Dual symmetric + short ROM (<400mm) + fast (<3000ms) + not explosive -> Shoulder Press (0.65)
   - Dual symmetric + medium ROM (400-600mm) -> Bent-Over Row (0.6)
   - Dual symmetric + long ROM (>600mm) -> Squat (0.6)
   - Dual symmetric + short ROM (<300mm) + slow (>3000ms) -> Bicep Curl (0.6)
   - Default -> Unknown (0.3)

**computeSimilarity()** -- Weighted per DETECT-05:
- ROM: 40% weight, normalized = 1 - |a.romMm - b.romMm| / max(a.romMm, b.romMm)
- Duration: 20% weight, normalized = 1 - |a.durationMs - b.durationMs| / max(a.durationMs, b.durationMs)
- Symmetry: 25% weight, normalized = 1 - |a.symmetryRatio - b.symmetryRatio|
- Shape: 15% weight, 1.0 if same VelocityShape, 0.0 if different

**evolveSignature()** -- Per DETECT-06:
- EMA with alpha=0.3: `new = existing * (1 - alpha) + observation * alpha`
- Apply to romMm, durationMs (as Float then toLong), symmetryRatio
- velocityProfile: use latest observation (categorical)
- cableConfig: use latest observation (categorical)
- Increment sampleCount

**Tests (RED first):**
- `classify returns history match when similarity above 0.85`
- `classify falls back to rules when no history`
- `classify returns Unknown for ambiguous signatures`
- `computeSimilarity returns 1.0 for identical signatures`
- `computeSimilarity weights ROM at 40 percent` (two signatures identical except ROM differs -> similarity drops by ~0.4 * romDelta)
- `evolveSignature applies EMA with alpha 0.3` (existing ROM=100, new ROM=200 -> result ROM=130)
- `evolveSignature increments sampleCount`
- `classify dual symmetric short ROM explosive returns Chest Press`

Commit RED: `test(11-01): add failing ExerciseClassifier tests`
Commit GREEN: `feat(11-01): implement ExerciseClassifier with weighted similarity and rule-based fallback`
  </action>
  <verify>
Run `./gradlew :shared:testDebugUnitTest --tests "com.devil.phoenixproject.domain.detection.ExerciseClassifierTest"` -- all tests pass.

Run all detection tests together: `./gradlew :shared:testDebugUnitTest --tests "com.devil.phoenixproject.domain.detection.*"` -- all pass.
  </verify>
  <done>ExerciseClassifier correctly classifies signatures using history matching (weighted similarity per DETECT-05) and rule-based fallback, with EMA signature evolution (DETECT-06). All 8+ tests pass.</done>
</task>

</tasks>

<verification>
- `./gradlew :shared:testDebugUnitTest --tests "com.devil.phoenixproject.domain.detection.*"` passes all tests
- DetectionModels.kt contains ExerciseSignature, ExerciseClassification, VelocityShape, CableUsage
- SignatureExtractor.extractSignature() accepts List<WorkoutMetric> and returns ExerciseSignature?
- ExerciseClassifier.classify() accepts signature + history map and returns ExerciseClassification
- ExerciseClassifier.computeSimilarity() uses weights: ROM 40%, duration 20%, symmetry 25%, shape 15%
- ExerciseClassifier.evolveSignature() applies EMA with alpha=0.3
</verification>

<success_criteria>
All domain detection logic is tested and working: signature extraction from WorkoutMetric streams, rule-based classification with history matching, weighted similarity computation, and EMA-based signature evolution.
</success_criteria>

<output>
After completion, create `.planning/phases/11-exercise-auto-detection/11-01-SUMMARY.md`
</output>
