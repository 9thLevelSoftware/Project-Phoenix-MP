---
phase: 06-core-engine
plan: 02
type: tdd
wave: 2
depends_on: ["06-01"]
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/VbtEngineTest.kt
autonomous: true

must_haves:
  truths:
    - "After completing a rep, MCV is calculated from average of absolute concentric velocities"
    - "Each rep is classified into one of 5 velocity zones (Explosive/Fast/Moderate/Slow/Grind) based on MCV"
    - "After rep 2+, velocity loss percentage is calculated relative to first rep's MCV"
    - "After rep 2+, estimated reps remaining is projected from velocity decay rate"
    - "shouldStopSet is true when velocity loss exceeds configured threshold (default 20%)"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt"
      provides: "computeVelocity() with real MCV calculation, zone classification, velocity loss tracking"
    - path: "shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/VbtEngineTest.kt"
      provides: "Tests for MCV calculation, zone boundaries, velocity loss, rep projection, auto-stop"
  key_links:
    - from: "BiomechanicsEngine.computeVelocity()"
      to: "BiomechanicsVelocityZone.fromMcv()"
      via: "Zone classification from MCV value"
      pattern: "fromMcv"
---

<objective>
Implement the VBT (Velocity Based Training) computation in BiomechanicsEngine: Mean Concentric Velocity calculation, velocity zone classification, velocity loss tracking across reps, remaining reps projection, and auto-stop recommendation.

Purpose: VBT is the core training metric that tells users how fast they're moving weight. Velocity loss across a set indicates fatigue -- when it exceeds a threshold (default 20%), the app recommends stopping to prevent junk volume.

Output: Working computeVelocity() implementation + comprehensive test suite.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-core-engine/06-01-SUMMARY.md
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/BiomechanicsModels.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/Models.kt
</context>

<feature>
  <name>VBT Engine - Velocity Computation</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
    shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/VbtEngineTest.kt
  </files>
  <behavior>
    Replace the stub `computeVelocity()` in BiomechanicsEngine with real VBT logic.

    **MCV Calculation (VBT-01):**
    - Input: List of WorkoutMetric for concentric phase
    - MCV = average of abs(velocityA) + abs(velocityB) / 2 across all samples (average of per-sample cable speeds)
    - Actually: use max(abs(velocityA), abs(velocityB)) per sample since cables move together -- take the higher reading as the movement velocity
    - Output: MCV in mm/s
    - Edge case: empty metrics list -> MCV = 0

    **Zone Classification (VBT-02):**
    - Use BiomechanicsVelocityZone.fromMcv() already defined in Plan 01
    - Input: MCV in mm/s
    - Zones: EXPLOSIVE >= 1000, FAST >= 750, MODERATE >= 500, SLOW >= 250, GRIND < 250

    **Velocity Loss (VBT-03):**
    - Track firstRepMcv (set on rep 1, persists until reset)
    - For rep N >= 2: velocityLossPercent = ((firstRepMcv - currentMcv) / firstRepMcv) * 100
    - Clamp to 0-100 range (if current rep is faster than first, loss = 0)
    - For rep 1: velocityLossPercent = null

    **Rep Projection (VBT-04):**
    - After rep 2+: estimate total reps before hitting velocityLossThreshold
    - Use linear regression on MCV values across reps to project when MCV will cross threshold
    - Simple approach: if losing X% per rep on average, project how many more reps until threshold
    - Formula: repsRemaining = (thresholdPercent - currentLossPercent) / avgLossPerRep
    - Clamp to 0..99 range, return null if projection is nonsensical (e.g., velocity increasing)

    **Auto-Stop (VBT-05):**
    - shouldStopSet = velocityLossPercent != null && velocityLossPercent >= velocityLossThresholdPercent
    - Default threshold: 20% (configurable via constructor parameter)

    Test cases:
    - Single metric with velocity (50, 0) -> MCV = 50 mm/s
    - MCV from 5 metrics with varying velocities -> correct average
    - Empty metrics -> MCV = 0, zone = GRIND
    - Zone boundaries: 249 -> GRIND, 250 -> SLOW, 499 -> SLOW, 500 -> MODERATE, 749 -> MODERATE, 750 -> FAST, 999 -> FAST, 1000 -> EXPLOSIVE
    - Rep 1 -> velocityLossPercent = null, shouldStopSet = false
    - Rep 2 at 80% of rep 1 velocity -> velocityLossPercent = 20, shouldStopSet = true (at default 20%)
    - Rep 2 at 90% of rep 1 velocity -> velocityLossPercent = 10, shouldStopSet = false
    - Rep faster than rep 1 -> velocityLossPercent = 0 (clamped)
    - Projection test: linear decay from rep 1-3, project rep 4+ correctly
  </behavior>
  <implementation>
    Replace computeVelocity() body in BiomechanicsEngine.kt:

    1. Calculate MCV: `val mcv = if (concentricMetrics.isEmpty()) 0f else concentricMetrics.map { maxOf(abs(it.velocityA.toFloat()), abs(it.velocityB.toFloat())) }.average().toFloat()`
    2. Classify zone: `val zone = BiomechanicsVelocityZone.fromMcv(mcv)`
    3. Track first rep: `if (firstRepMcv == null) firstRepMcv = mcv`
    4. Calculate loss: `val loss = firstRepMcv?.let { if (it > 0f) ((it - mcv) / it * 100f).coerceAtLeast(0f) else null }`
    5. Set loss to null for rep 1 (when repNumber == 1 or only one result so far)
    6. Project remaining: use repResults history to calculate avg loss per rep, project forward
    7. Return VelocityResult with all fields

    Also update processRep() so it stores firstRepMcv on rep 1.

    The test file should create WorkoutMetric instances with specific velocityA/velocityB values and verify all VBT outputs.
  </implementation>
</feature>

<verification>
1. `./gradlew :androidApp:testDebugUnitTest` -- all tests pass including new VBT tests
2. `./gradlew :androidApp:assembleDebug` -- build succeeds
3. VbtEngineTest.kt contains tests for MCV calculation, all 5 zone boundaries, velocity loss tracking, rep projection, and auto-stop
</verification>

<success_criteria>
- computeVelocity() calculates real MCV from concentric WorkoutMetric samples
- All 5 velocity zones correctly classified at boundary values
- Velocity loss tracked relative to first rep, clamped to 0-100%
- Rep projection estimates remaining reps from velocity decay
- shouldStopSet true when loss exceeds threshold
- All tests pass (RED -> GREEN -> REFACTOR cycle)
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-engine/06-02-SUMMARY.md`
</output>
