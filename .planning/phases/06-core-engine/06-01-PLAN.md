---
phase: 06-core-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/BiomechanicsModels.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ActiveSessionEngine.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/WorkoutCoordinator.kt
autonomous: true

must_haves:
  truths:
    - "BiomechanicsEngine exists and exposes per-rep VBT, force curve, and asymmetry results via StateFlow"
    - "Each completed rep's MetricSamples are segmented from collectedMetrics using rep boundary timestamps"
    - "BiomechanicsEngine computation runs on Dispatchers.Default, not main thread"
    - "Raw data capture is unconditional regardless of subscription tier"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/BiomechanicsModels.kt"
      provides: "VelocityResult, ForceCurveResult, AsymmetryResult, BiomechanicsRepResult, StrengthProfile, BiomechanicsVelocityZone data classes"
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt"
      provides: "BiomechanicsEngine class with processRep(), StateFlow outputs, reset()"
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/WorkoutCoordinator.kt"
      provides: "BiomechanicsEngine instance + repBoundaryTimestamps list + biomechanics StateFlow getters"
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ActiveSessionEngine.kt"
      provides: "Rep boundary timestamp capture + biomechanics processing call after each rep"
  key_links:
    - from: "ActiveSessionEngine.handleRepNotification()"
      to: "BiomechanicsEngine.processRep()"
      via: "Captures rep boundary timestamp, segments collectedMetrics, calls engine"
      pattern: "biomechanicsEngine.*processRep"
    - from: "BiomechanicsEngine"
      to: "WorkoutCoordinator StateFlows"
      via: "Engine updates coordinator's biomechanics StateFlows"
      pattern: "_biomechanicsResult"
---

<objective>
Create BiomechanicsEngine infrastructure: domain models for VBT/force curve/asymmetry results, the engine shell with StateFlow exposure, rep boundary timestamp capture, and MetricSample segmentation per rep.

Purpose: All three computation engines (VBT, Force Curve, Asymmetry) need the same infrastructure -- rep-segmented MetricSample data and a shared engine that exposes results via StateFlow. This plan builds that foundation so Plans 02-04 can implement pure computation functions independently.

Output: BiomechanicsModels.kt (domain types), BiomechanicsEngine.kt (engine with stub compute methods), modified WorkoutCoordinator (state bus), modified ActiveSessionEngine (rep boundary capture + engine invocation).
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/RepMetrics.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/LedFeedback.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/Models.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/WorkoutCoordinator.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ActiveSessionEngine.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/RepQualityScorer.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create biomechanics domain models and engine shell</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/BiomechanicsModels.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
  </files>
  <action>
Create BiomechanicsModels.kt in domain/model/ with these data classes:

1. **BiomechanicsVelocityZone** enum: EXPLOSIVE, FAST, MODERATE, SLOW, GRIND with MCV thresholds.
   NOTE: This is SEPARATE from the existing VelocityZone enum in LedFeedback.kt (which maps absolute velocity to LED colors).
   Biomechanics zones classify Mean Concentric Velocity for training load analysis:
   - EXPLOSIVE: MCV >= 1.0 m/s (>= 1000 mm/s)
   - FAST: MCV >= 0.75 m/s (>= 750 mm/s)
   - MODERATE: MCV >= 0.5 m/s (>= 500 mm/s)
   - SLOW: MCV >= 0.25 m/s (>= 250 mm/s)
   - GRIND: MCV < 0.25 m/s (< 250 mm/s)
   Include a companion `fromMcv(mcvMmPerSec: Float): BiomechanicsVelocityZone` function.

2. **VelocityResult** data class:
   - meanConcentricVelocityMmS: Float (MCV in mm/s)
   - peakVelocityMmS: Float
   - zone: BiomechanicsVelocityZone
   - velocityLossPercent: Float? (null for rep 1)
   - estimatedRepsRemaining: Int? (null until rep 2+)
   - shouldStopSet: Boolean (true when velocity loss exceeds threshold)
   - repNumber: Int

3. **StrengthProfile** enum: ASCENDING, DESCENDING, BELL_SHAPED, FLAT

4. **ForceCurveResult** data class:
   - normalizedForceN: FloatArray (force values at 0-100% ROM, 101 points)
   - normalizedPositionPct: FloatArray (0.0, 1.0, 2.0, ..., 100.0)
   - stickingPointPct: Float? (ROM position of minimum force, null if curve too short)
   - strengthProfile: StrengthProfile
   - repNumber: Int
   Include custom equals/hashCode for FloatArray fields (follow RepMetricData pattern).

5. **AsymmetryResult** data class:
   - asymmetryPercent: Float (0-100, where 0 = perfectly balanced)
   - dominantSide: String ("A" or "B", or "BALANCED" if < 2%)
   - avgLoadA: Float (kg)
   - avgLoadB: Float (kg)
   - repNumber: Int

6. **BiomechanicsRepResult** data class:
   - velocity: VelocityResult
   - forceCurve: ForceCurveResult
   - asymmetry: AsymmetryResult
   - repNumber: Int
   - timestamp: Long

7. **BiomechanicsSetSummary** data class:
   - repResults: List<BiomechanicsRepResult>
   - avgMcvMmS: Float
   - peakVelocityMmS: Float
   - totalVelocityLossPercent: Float?
   - zoneDistribution: Map<BiomechanicsVelocityZone, Int>
   - avgAsymmetryPercent: Float
   - dominantSide: String
   - strengthProfile: StrengthProfile
   - avgForceCurve: ForceCurveResult? (averaged across reps)

Create BiomechanicsEngine.kt in domain/premium/ with:

```kotlin
class BiomechanicsEngine(
    private val velocityLossThresholdPercent: Float = 20f
) {
    private val _latestRepResult = MutableStateFlow<BiomechanicsRepResult?>(null)
    val latestRepResult: StateFlow<BiomechanicsRepResult?> = _latestRepResult.asStateFlow()

    private val repResults = mutableListOf<BiomechanicsRepResult>()
    private var firstRepMcv: Float? = null

    /**
     * Process a completed rep's metric samples and produce biomechanics results.
     * Called from ActiveSessionEngine after each rep boundary detection.
     *
     * @param repNumber 1-indexed rep number
     * @param metrics List of WorkoutMetric samples for this rep's concentric phase
     * @param allRepMetrics All metrics for this rep (concentric + eccentric)
     * @param timestamp Rep completion timestamp
     */
    fun processRep(
        repNumber: Int,
        concentricMetrics: List<WorkoutMetric>,
        allRepMetrics: List<WorkoutMetric>,
        timestamp: Long
    ): BiomechanicsRepResult {
        val velocity = computeVelocity(repNumber, concentricMetrics)
        val forceCurve = computeForceCurve(repNumber, concentricMetrics)
        val asymmetry = computeAsymmetry(repNumber, allRepMetrics)

        val result = BiomechanicsRepResult(
            velocity = velocity,
            forceCurve = forceCurve,
            asymmetry = asymmetry,
            repNumber = repNumber,
            timestamp = timestamp
        )

        repResults.add(result)
        _latestRepResult.value = result
        return result
    }

    fun getSetSummary(): BiomechanicsSetSummary? { /* stub - returns null if empty */ }

    fun reset() {
        repResults.clear()
        firstRepMcv = null
        _latestRepResult.value = null
    }

    // --- Stub computation methods (implemented in Plans 02-04) ---
    internal fun computeVelocity(repNumber: Int, concentricMetrics: List<WorkoutMetric>): VelocityResult {
        // Plan 02 will implement this
        return VelocityResult(0f, 0f, BiomechanicsVelocityZone.GRIND, null, null, false, repNumber)
    }

    internal fun computeForceCurve(repNumber: Int, concentricMetrics: List<WorkoutMetric>): ForceCurveResult {
        // Plan 03 will implement this
        return ForceCurveResult(FloatArray(0), FloatArray(0), null, StrengthProfile.FLAT, repNumber)
    }

    internal fun computeAsymmetry(repNumber: Int, allRepMetrics: List<WorkoutMetric>): AsymmetryResult {
        // Plan 04 will implement this
        return AsymmetryResult(0f, "BALANCED", 0f, 0f, repNumber)
    }
}
```

Use `internal` on compute methods so Plans 02-04 can replace them (same module). Import WorkoutMetric. Use Dispatchers.Default note in KDoc but don't add withContext here -- the caller (ActiveSessionEngine) will dispatch to Default.
  </action>
  <verify>
    Build compiles: `./gradlew :shared:compileKotlinMetadata` passes.
    BiomechanicsModels.kt contains all 7 types.
    BiomechanicsEngine.kt has processRep(), getSetSummary(), reset(), and 3 internal compute stubs.
  </verify>
  <done>
    BiomechanicsModels.kt exists with VelocityResult, ForceCurveResult, AsymmetryResult, BiomechanicsRepResult, BiomechanicsSetSummary, BiomechanicsVelocityZone, StrengthProfile.
    BiomechanicsEngine.kt exists with stub compute methods, StateFlow output, and processRep orchestrator.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire rep boundary capture and biomechanics processing into workout flow</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/WorkoutCoordinator.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ActiveSessionEngine.kt
  </files>
  <action>
**WorkoutCoordinator changes:**

1. Add BiomechanicsEngine instance (like repQualityScorer pattern):
   ```kotlin
   val biomechanicsEngine = BiomechanicsEngine()
   ```

2. Add rep boundary timestamp tracking list:
   ```kotlin
   internal val repBoundaryTimestamps = mutableListOf<Long>()
   ```

3. Add public StateFlow getters that delegate to engine:
   ```kotlin
   val latestBiomechanicsResult: StateFlow<BiomechanicsRepResult?>
       get() = biomechanicsEngine.latestRepResult
   ```

**ActiveSessionEngine changes:**

1. In `handleRepNotification()`, after the existing `if (repCountAfter > repCountBefore)` block that calls `scoreCurrentRep()`, add biomechanics processing:

   ```kotlin
   if (repCountAfter > repCountBefore) {
       scoreCurrentRep(repCountAfter)

       // Capture rep boundary timestamp for MetricSample segmentation
       val now = KmpUtils.currentTimeMillis()
       coordinator.repBoundaryTimestamps.add(now)

       // Segment metrics for this rep and process biomechanics
       processBiomechanicsForRep(repCountAfter, now)
   }
   ```

2. Add `processBiomechanicsForRep()` private method:
   ```kotlin
   private fun processBiomechanicsForRep(repNumber: Int, timestamp: Long) {
       scope.launch(kotlinx.coroutines.Dispatchers.Default) {
           val allMetrics = coordinator.collectedMetrics.toList()
           val boundaries = coordinator.repBoundaryTimestamps.toList()

           // Segment: metrics between previous boundary and current boundary
           val prevBoundary = if (boundaries.size >= 2) boundaries[boundaries.size - 2] else 0L
           val currentBoundary = boundaries.last()

           val repMetrics = allMetrics.filter { it.timestamp in (prevBoundary + 1)..currentBoundary }
           if (repMetrics.isEmpty()) return@launch

           // Split into concentric/eccentric using RepPhase tracking
           // Approximate: first half = concentric, second half = eccentric
           // (Real phase detection uses position direction change)
           val midpoint = repMetrics.size / 2
           val concentricMetrics = if (midpoint > 0) repMetrics.take(midpoint) else repMetrics

           coordinator.biomechanicsEngine.processRep(
               repNumber = repNumber,
               concentricMetrics = concentricMetrics,
               allRepMetrics = repMetrics,
               timestamp = timestamp
           )
       }
   }
   ```

   IMPORTANT: Use `Dispatchers.Default` for the coroutine to satisfy DATA-03 (computation off UI thread).

3. In `handleSetCompletion()`, after the existing `coordinator.repQualityScorer.reset()` line, add:
   ```kotlin
   coordinator.biomechanicsEngine.reset()
   coordinator.repBoundaryTimestamps.clear()
   ```

4. In the existing `resetForNewWorkout()` method (or wherever collectedMetrics is cleared at workout start), also clear:
   ```kotlin
   coordinator.biomechanicsEngine.reset()
   coordinator.repBoundaryTimestamps.clear()
   ```

No tier gating on the processing call (DATA-04: raw data capture is unconditional).
  </action>
  <verify>
    Build compiles: `./gradlew :shared:compileKotlinMetadata` passes.
    Full Android build: `./gradlew :androidApp:assembleDebug` passes.
    Unit tests: `./gradlew :androidApp:testDebugUnitTest` passes (no regressions).
    Grep confirms: `processBiomechanicsForRep` exists in ActiveSessionEngine.
    Grep confirms: `biomechanicsEngine` exists in WorkoutCoordinator.
    Grep confirms: `Dispatchers.Default` used in processBiomechanicsForRep launch.
  </verify>
  <done>
    Rep boundary timestamps captured on each rep completion.
    collectedMetrics segmented per-rep using boundary timestamps.
    BiomechanicsEngine.processRep() called after each rep on Dispatchers.Default.
    Engine and timestamps cleared at set completion and workout reset.
    No tier gating on data capture path.
    All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew :androidApp:assembleDebug` succeeds
2. `./gradlew :androidApp:testDebugUnitTest` succeeds (no regressions)
3. BiomechanicsModels.kt contains all domain types
4. BiomechanicsEngine.kt exposes StateFlow and has stub compute methods
5. ActiveSessionEngine calls processRep after rep detection on Dispatchers.Default
6. WorkoutCoordinator exposes biomechanics StateFlows
7. No FeatureGate checks in data capture path (GATE-04 compliance)
</verification>

<success_criteria>
- BiomechanicsEngine processes each rep's MetricSamples and exposes results via StateFlow
- Rep boundary timestamps enable proper per-rep metric segmentation
- All computation dispatched to Dispatchers.Default
- Stub compute methods return default values (Plans 02-04 implement real logic)
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-engine/06-01-SUMMARY.md`
</output>
