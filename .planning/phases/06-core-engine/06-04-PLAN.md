---
phase: 06-core-engine
plan: 04
type: tdd
wave: 2
depends_on: ["06-01"]
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/AsymmetryEngineTest.kt
autonomous: true

must_haves:
  truths:
    - "After completing a rep, cable asymmetry percentage is calculated from loadA vs loadB averages"
    - "Dominant side (A or B) is identified based on which cable had higher average load"
    - "Asymmetry below 2% is reported as BALANCED (no dominant side)"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt"
      provides: "computeAsymmetry() with per-rep asymmetry calculation and dominant side detection"
    - path: "shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/AsymmetryEngineTest.kt"
      provides: "Tests for asymmetry calculation, dominant side, balanced threshold, edge cases"
  key_links:
    - from: "BiomechanicsEngine.computeAsymmetry()"
      to: "AsymmetryResult"
      via: "Returns asymmetry percentage and dominant side"
      pattern: "computeAsymmetry"
---

<objective>
Implement cable asymmetry computation in BiomechanicsEngine: calculate per-rep asymmetry percentage from loadA/loadB data and identify dominant cable side.

Purpose: The Vitruvian trainer has independent cable load measurements (loadA/loadB). Bilateral asymmetry detection reveals if a user is favoring one side, which is critical for injury prevention and balanced strength development. Asymmetry above 10-15% warrants attention.

Output: Working computeAsymmetry() implementation + comprehensive test suite.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-core-engine/06-01-SUMMARY.md
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/BiomechanicsModels.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/Models.kt
</context>

<feature>
  <name>Asymmetry Engine - Per-Rep Cable Asymmetry and Dominant Side</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
    shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/AsymmetryEngineTest.kt
  </files>
  <behavior>
    Replace the stub `computeAsymmetry()` in BiomechanicsEngine with real asymmetry logic.

    **Asymmetry Calculation (ASYM-01):**
    - Input: List of WorkoutMetric for entire rep (concentric + eccentric phases)
    - Calculate average loadA across all samples: avgLoadA = mean(metrics.map { it.loadA })
    - Calculate average loadB across all samples: avgLoadB = mean(metrics.map { it.loadB })
    - Asymmetry formula: asymmetryPercent = abs(avgLoadA - avgLoadB) / max(avgLoadA, avgLoadB) * 100
    - Guard: if max(avgLoadA, avgLoadB) <= 0 (no load), return 0% asymmetry with BALANCED
    - Clamp to 0-100 range

    **Dominant Side Detection (ASYM-02):**
    - If asymmetryPercent < 2.0: dominantSide = "BALANCED" (within measurement noise)
    - If avgLoadA > avgLoadB: dominantSide = "A"
    - If avgLoadB > avgLoadA: dominantSide = "B"
    - If exactly equal: dominantSide = "BALANCED"

    Test cases:
    - Perfectly balanced: loadA=50, loadB=50 -> 0% asymmetry, BALANCED
    - Slight imbalance: loadA=51, loadB=49 -> ~3.9% asymmetry, dominant = A
    - Under 2% threshold: loadA=50.5, loadB=49.5 -> ~1.98% asymmetry, BALANCED
    - Significant imbalance: loadA=60, loadB=40 -> 33.3% asymmetry, dominant = A
    - Side B dominant: loadA=40, loadB=60 -> 33.3% asymmetry, dominant = B
    - Multiple samples with varying loads: correct average calculation
    - Zero load (both cables): 0% asymmetry, BALANCED
    - Single sample: correct calculation from one metric
    - Empty metrics list: 0% asymmetry, BALANCED
    - Very high asymmetry (one cable near zero): approaches 100%
  </behavior>
  <implementation>
    Replace computeAsymmetry() body in BiomechanicsEngine.kt:

    ```kotlin
    internal fun computeAsymmetry(repNumber: Int, allRepMetrics: List<WorkoutMetric>): AsymmetryResult {
        if (allRepMetrics.isEmpty()) {
            return AsymmetryResult(0f, "BALANCED", 0f, 0f, repNumber)
        }

        val avgLoadA = allRepMetrics.map { it.loadA }.average().toFloat()
        val avgLoadB = allRepMetrics.map { it.loadB }.average().toFloat()
        val maxLoad = maxOf(avgLoadA, avgLoadB)

        if (maxLoad <= 0f) {
            return AsymmetryResult(0f, "BALANCED", avgLoadA, avgLoadB, repNumber)
        }

        val asymmetry = (abs(avgLoadA - avgLoadB) / maxLoad * 100f).coerceIn(0f, 100f)

        val dominantSide = when {
            asymmetry < 2f -> "BALANCED"
            avgLoadA > avgLoadB -> "A"
            avgLoadB > avgLoadA -> "B"
            else -> "BALANCED"
        }

        return AsymmetryResult(
            asymmetryPercent = asymmetry,
            dominantSide = dominantSide,
            avgLoadA = avgLoadA,
            avgLoadB = avgLoadB,
            repNumber = repNumber
        )
    }
    ```

    This is the simplest of the three engines. The test file creates WorkoutMetric instances with specific loadA/loadB values and verifies asymmetry percentage and dominant side.

    Use delta tolerance (0.1f) for float comparisons in tests since we're dealing with averages.
  </implementation>
</feature>

<verification>
1. `./gradlew :androidApp:testDebugUnitTest` -- all tests pass including new asymmetry tests
2. `./gradlew :androidApp:assembleDebug` -- build succeeds
3. AsymmetryEngineTest.kt contains tests for balanced, A-dominant, B-dominant, threshold boundary, zero load, empty input
</verification>

<success_criteria>
- computeAsymmetry() calculates correct percentage from loadA/loadB averages
- Dominant side correctly identified (A, B, or BALANCED below 2%)
- Zero load and empty input handled gracefully
- Float comparisons use appropriate tolerance
- All tests pass (RED -> GREEN -> REFACTOR cycle)
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-engine/06-04-SUMMARY.md`
</output>
