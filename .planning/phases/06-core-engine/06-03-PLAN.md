---
phase: 06-core-engine
plan: 03
type: tdd
wave: 2
depends_on: ["06-01"]
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/ForceCurveEngineTest.kt
autonomous: true

must_haves:
  truths:
    - "After completing a rep, a force-position curve is constructed from load and position data"
    - "Force curve is normalized to 0-100% ROM (101 data points) for rep-to-rep comparison"
    - "Sticking point is detected as the ROM position with minimum force in the concentric phase"
    - "Strength profile is classified as Ascending, Descending, Bell-shaped, or Flat based on curve shape"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt"
      provides: "computeForceCurve() with normalization, sticking point detection, and profile classification"
    - path: "shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/ForceCurveEngineTest.kt"
      provides: "Tests for curve construction, normalization, sticking point, all 4 strength profiles"
  key_links:
    - from: "BiomechanicsEngine.computeForceCurve()"
      to: "ForceCurveResult"
      via: "Returns normalized curve with sticking point and profile"
      pattern: "computeForceCurve"
---

<objective>
Implement force curve computation in BiomechanicsEngine: construct per-rep force-position curves from WorkoutMetric data, normalize to 0-100% ROM, detect sticking points, and classify strength profiles.

Purpose: Force curves reveal WHERE in the range of motion a user is strongest/weakest. Sticking point detection identifies the specific ROM position where the user struggles most. Strength profile classification (Ascending/Descending/Bell/Flat) helps users understand their movement pattern.

Output: Working computeForceCurve() implementation + comprehensive test suite.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-core-engine/06-01-SUMMARY.md
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/BiomechanicsModels.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/model/Models.kt
</context>

<feature>
  <name>Force Curve Engine - Construction, Normalization, Sticking Point, Profile</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/domain/premium/BiomechanicsEngine.kt
    shared/src/commonTest/kotlin/com/devil/phoenixproject/domain/premium/ForceCurveEngineTest.kt
  </files>
  <behavior>
    Replace the stub `computeForceCurve()` in BiomechanicsEngine with real force curve logic.

    **Force Curve Construction (FORCE-01):**
    - Input: List of WorkoutMetric for concentric phase (sorted by timestamp)
    - For each sample: force = (loadA + loadB), position = max(positionA, positionB)
    - Subtract load baselines if available (machine has ~4kg base tension)
    - Construct raw force-position pairs sorted by position (ascending = concentric direction)
    - Edge case: fewer than 3 samples -> return empty curve with null sticking point

    **ROM Normalization (FORCE-02):**
    - Map raw positions to 0-100% ROM (101 equally-spaced points)
    - minPos = min position in concentric phase, maxPos = max position
    - For each of 101 points (0%, 1%, ..., 100%): interpolate force value from raw data
    - Use linear interpolation between nearest raw data points
    - Output: normalizedForceN[101] and normalizedPositionPct[101] (0.0f, 1.0f, ..., 100.0f)

    **Sticking Point Detection (FORCE-03):**
    - Find the index of minimum force in the normalized curve
    - Skip first 5% and last 5% (transition noise at ROM boundaries)
    - stickingPointPct = normalizedPositionPct[minForceIndex]
    - Return null if curve has fewer than 10 valid points

    **Strength Profile Classification (FORCE-04):**
    - Divide normalized curve into 3 equal segments (0-33%, 34-66%, 67-100%)
    - Calculate average force for each segment (bottom, middle, top)
    - Classification rules (using 15% threshold for "significantly higher"):
      - ASCENDING: top > bottom * 1.15 AND top > middle (force increases through ROM)
      - DESCENDING: bottom > top * 1.15 AND bottom > middle (force decreases through ROM)
      - BELL_SHAPED: middle > bottom * 1.15 AND middle > top * 1.15 (force peaks in middle)
      - FLAT: none of the above (relatively even force distribution)

    Test cases:
    - 3 samples with ascending positions and forces -> normalized curve has 101 points
    - Normalization: raw positions [100, 200, 300] -> normalized to [0%, 50%, 100%]
    - Interpolation: force at 25% position correctly interpolated between 0% and 50% values
    - Sticking point: curve with dip at 40% ROM -> stickingPointPct = 40.0
    - Sticking point skips edges: minimum at 2% ROM -> stickingPointPct is the min AFTER 5% ROM
    - Ascending profile: forces [10, 15, 25] in bottom/mid/top thirds -> ASCENDING
    - Descending profile: forces [25, 15, 10] -> DESCENDING
    - Bell-shaped profile: forces [10, 25, 10] -> BELL_SHAPED
    - Flat profile: forces [15, 16, 15] -> FLAT
    - Empty/short metrics -> empty curve, null sticking point, FLAT profile
    - 2 samples only -> empty curve returned (minimum 3 required)
  </behavior>
  <implementation>
    Replace computeForceCurve() body in BiomechanicsEngine.kt:

    1. Guard: if fewer than 3 concentric metrics, return empty ForceCurveResult with FLAT profile
    2. Extract raw force-position pairs: `metrics.map { Pair(max(it.positionA, it.positionB), it.loadA + it.loadB) }`
    3. Sort by position ascending
    4. Calculate minPos, maxPos, romRange = maxPos - minPos
    5. Guard: if romRange < 1.0, return empty curve
    6. Normalize to 101 points with linear interpolation:
       ```
       for (pct in 0..100) {
           val targetPos = minPos + (romRange * pct / 100f)
           // Find bracketing raw points and interpolate
       }
       ```
    7. Detect sticking point: find min force index in range [5..95] of normalized curve
    8. Classify profile: split into thirds, compare averages, apply threshold rules
    9. Return ForceCurveResult

    Add private helper: `interpolateForce(rawPairs: List<Pair<Float, Float>>, targetPosition: Float): Float`
    that finds the two nearest raw data points and linearly interpolates.
  </implementation>
</feature>

<verification>
1. `./gradlew :androidApp:testDebugUnitTest` -- all tests pass including new force curve tests
2. `./gradlew :androidApp:assembleDebug` -- build succeeds
3. ForceCurveEngineTest.kt contains tests for construction, normalization, interpolation, sticking point, and all 4 profiles
</verification>

<success_criteria>
- computeForceCurve() produces 101-point normalized curve from raw position/load data
- Linear interpolation correctly maps raw samples to normalized ROM positions
- Sticking point detected at minimum force position (excluding 5% edge margins)
- All 4 strength profiles correctly classified with 15% threshold
- Empty/short input handled gracefully
- All tests pass (RED -> GREEN -> REFACTOR cycle)
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-engine/06-03-SUMMARY.md`
</output>
